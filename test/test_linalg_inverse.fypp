#:set REAL_KINDS    = ["sp", "dp", "qp"]
#:set REAL_INITIALS = ["s","d","q"]
#:set REAL_TYPES    = ["real({})".format(k) for k in REAL_KINDS]
#:set REAL_KINDS_TYPES = list(zip(REAL_KINDS, REAL_TYPES, REAL_INITIALS))
#:set CMPL_INITIALS = ["c","z","w"]
#:set CMPL_TYPES    = ["complex({})".format(k) for k in REAL_KINDS]
#:set CMPL_KINDS_TYPES = list(zip(REAL_KINDS, CMPL_TYPES, CMPL_INITIALS))
! Test inverse matrix
module test_linalg_inverse
    use stdlib_linalg_interface

    implicit none (type,external)

    contains

    !> Matrix inversion tests
    subroutine test_inverse_matrix(error)
        logical, intent(out) :: error

        #:for rk,rt,ri in REAL_KINDS_TYPES
        call test_${ri}$_eye_inverse(error)
        if (error) return
        #: endfor
        #:for ck,ct,ci in CMPL_KINDS_TYPES
        call test_${ci}$_eye_inverse(error)
        if (error) return
        #: endfor

    end subroutine test_inverse_matrix

    !> Invert identity matrix
    #:for rk,rt,ri in REAL_KINDS_TYPES
    subroutine test_${ri}$_eye_inverse(error)
        logical, intent(out) :: error

        type(linalg_state) :: state

        integer(ilp) :: i,j
        integer(ilp), parameter :: n = 500_ilp

        ${rt}$ :: a(n,n),inva(n,n)

        do concurrent (i=1:n,j=1:n)
          a(i,j) = merge(1.0_${rk}$,0.0_${rk}$,i==j)
        end do

        !> Invert function
        inva = inv(a,err=state)
        error = state%error() .or. .not.all(abs(a-inva)==0.0_${rk}$)
        if (error) return

        !> Inverse subroutine
        call invert(a,err=state)
        error = state%error() .or. .not.all(a==inva)

    end subroutine test_${ri}$_eye_inverse

    #:endfor

    !> Invert identity matrix
    #:for ck,ct,ci in CMPL_KINDS_TYPES
    subroutine test_${ci}$_eye_inverse(error)
        logical, intent(out) :: error

        type(linalg_state) :: state

        integer(ilp) :: i,j
        integer(ilp), parameter :: n = 500_ilp

        ${ct}$ :: a(n,n),inva(n,n)

        do concurrent (i=1:n,j=1:n)
          a(i,j) = merge((1.0_${ck}$,1.0_${ck}$),(0.0_${ck}$,0.0_${ck}$),i==j)
        end do

        !> Invert function
        inva = inv(a,err=state)
        error = state%error() .or. .not.all(abs(a-inva)==0.0_${ck}$)
        if (error) return

        !> Inverse subroutine
        call invert(a,err=state)
        error = state%error() .or. .not.all(a==inva)

    end subroutine test_${ci}$_eye_inverse

    #:endfor

end module test_linalg_inverse


