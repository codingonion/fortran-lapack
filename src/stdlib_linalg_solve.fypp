#:set REAL_KINDS    = ["sp", "dp", "qp"]
#:set REAL_INITIALS = ["s","d","q"]
#:set REAL_TYPES    = ["real({})".format(k) for k in REAL_KINDS]
#:set REAL_KINDS_TYPES = list(zip(REAL_KINDS, REAL_TYPES, REAL_INITIALS))
#:set CMPL_INITIALS = ["c","z","w"]
#:set CMPL_TYPES    = ["complex({})".format(k) for k in REAL_KINDS]
#:set CMPL_KINDS_TYPES = list(zip(REAL_KINDS, CMPL_TYPES, CMPL_INITIALS))
#:set ALL_KINDS_TYPES = list(zip(REAL_KINDS+REAL_KINDS,REAL_TYPES+CMPL_TYPES,REAL_INITIALS+CMPL_INITIALS))

#:set RANK_SUFFIX = ["_one","_multiple"]
#:set RANK_SYMBOL = [":",":,:"]
#:set ALL_RANKS = list(zip(RANK_SYMBOL,RANK_SUFFIX))

module stdlib_linalg_solve
     use stdlib_linalg_constants
     use stdlib_linalg_blas
     use stdlib_linalg_lapack
     use stdlib_linalg_state
     use iso_fortran_env,only:real32,real64,real128,int8,int16,int32,int64,stderr => error_unit
     implicit none(type,external)
     private

     !> Solve a linear system
     public :: solve


     ! Scipy: solve(a, b, lower=False, overwrite_a=False, overwrite_b=False, check_finite=True, assume_a='gen', transposed=False)[source]#
     ! IMSL: lu_solve(a, b, transpose=False)


     interface solve
        #:for nd,ndsuf in ALL_RANKS
        #:for rk,rt,ri in ALL_KINDS_TYPES
        module procedure stdlib_linalg_${ri}$solve${ndsuf}$
        #:endfor
        #:endfor
     end interface solve


     contains

     #:for nd,ndsuf in ALL_RANKS
     #:for rk,rt,ri in ALL_KINDS_TYPES
     ! Compute the solution to a real system of linear equations A * X = B
     function stdlib_linalg_${ri}$solve${ndsuf}$(a,b,err) result(x)
         ${rt}$,                     intent(inout) :: a(:,:)
         ${rt}$,                     intent(in)    :: b(${nd}$)
         type(linalg_state), optional, intent(out) :: err
         ${rt}$, allocatable, target :: x(${nd}$)

         ! Local variables
         type(linalg_state) :: err0
         integer(ilp) :: lda,n,ldb,nrhs,info
         integer(ilp), allocatable :: ipiv(:)
         ${rt}$, pointer :: xmat(:,:)
         character(*), parameter :: this = 'solve'

         !> Problem sizes
         lda  = size(a,1,kind=ilp)
         n    = size(a,2,kind=ilp)
         ldb  = size(b,1,kind=ilp)
         nrhs = size(b  ,kind=ilp)/ldb

         if (lda<1 .or. n<1 .or. ldb<1 .or. lda/=n .or. ldb/=n) then
            err0 = linalg_state(this,LINALG_VALUE_ERROR,'invalid sizes: a=[',lda,',',n,'],',&
                                                                       'b=[',ldb,',',nrhs,']')
            goto 1
         end if

         ! Pivot indices
         allocate(ipiv(n))

         ! Initialize solution with the rhs
         allocate(x,source=b)
         xmat(1:n,1:nrhs) => x

         ! Solve system
         call gesv(n,nrhs,a,lda,ipiv,xmat,ldb,info)

         ! Process output
         select case (info)
            case (0)
                ! Success
            case (-1)
                err0 = linalg_state(this,LINALG_VALUE_ERROR,'invalid problem size n=',n)
            case (-2)
                err0 = linalg_state(this,LINALG_VALUE_ERROR,'invalid rhs size n=',nrhs)
            case (-4)
                err0 = linalg_state(this,LINALG_VALUE_ERROR,'invalid matrix size a=[',lda,',',n,']')
            case (-7)
                err0 = linalg_state(this,LINALG_ERROR,'invalid matrix size a=[',lda,',',n,']')
            case (1:)
                err0 = linalg_state(this,LINALG_ERROR,'singular matrix')
            case default
                err0 = linalg_state(this,LINALG_INTERNAL_ERROR,'catastrophic error')
         end select

         ! Process output
         1 call linalg_error_handling(err0,err)

     end function stdlib_linalg_${ri}$solve${ndsuf}$


     #:endfor
     #:endfor

end module stdlib_linalg_solve
