#:include "common.fypp"
module stdlib_linalg_determinant
     use stdlib_linalg_constants
     use stdlib_linalg_blas
     use stdlib_linalg_lapack
     use stdlib_linalg_state
     use iso_fortran_env,only:real32,real64,real128,int8,int16,int32,int64,stderr => error_unit
     implicit none(type,external)
     private

     !> Determinant of a rectangular matrix
     public :: det

     character(*), parameter :: this = 'svd'

     ! Numpy: svd(a, full_matrices=True, compute_uv=True, hermitian=False)
     ! Scipy: svd(a, full_matrices=True, compute_uv=True, overwrite_a=False, check_finite=True, lapack_driver='gesdd')


     interface det
        !!!#:for rk,rt,ri in ALL_KINDS_TYPES
        module procedure stdlib_linalg_svd_dp
        !!!#:endfor
     end interface det


     contains

     !!!#:for rk,rt,ri in ALL_KINDS_TYPES
     ! Compute determinant of a square matrix A
     pure subroutine stdlib_linalg_svd_dp(a,overwrite_a,full_matrices,err)
         !> Input matrix a[m,n]
         real(dp), intent(inout), target :: a(:,:)
         !> Array of singular values
         real(dp), intent(out) :: s(:)
         !> [optional] Can A data be overwritten and destroyed?
         logical(lk), optional, intent(in) :: overwrite_a
         !> [optional] full matrices have shape(u)==[m,m], shape(vh)==[n,n] (default); otherwise
         !> they are shape(u)==[m,k] and shape(vh)==[k,n] with k=min(m,n)
         logical(lk), optional, intent(in) :: full_matrices
         !> [optional] state return flag. On error if not requested, the code will stop
         type(linalg_state), optional, intent(out) :: err
         !> Result: matrix determinant
         real(dp) :: det

         !> Local variables
         type(linalg_state) :: err0
         integer(ilp) :: m,n,lda,info,perm,k
         integer(ilp), allocatable :: ipiv(:)
         logical(lk) :: copy_a,full_storage
         character :: job_ID
         real(dp), pointer :: amat(:,:)

         !> Matrix determinant size
         m   = size(a,1,kind=ilp)
         n   = size(a,2,kind=ilp)
         k   = min(m,n)
         lda = m

         if (.not.k>0) then
            err0 = linalg_state(this,LINALG_VALUE_ERROR,'invalid or matrix size: a=[',m,',',n,']')
            goto 1
         end if

         if (.not.size(s,kind=ilp)>=k) then
            err0 = linalg_state(this,LINALG_VALUE_ERROR,'singular value array has insufficient size:',&
                                                        ' s=[',size(s,kind=ilp),'], k=',k)
            goto 1
         endif

         ! Can A be overwritten? By default, do not overwrite
         if (present(overwrite_a)) then
            copy_a = .not.overwrite_a
         else
            copy_a = .true._lk
         endif

         ! Full-size matrices
         if (present(full_matrices)) then
            full_storage = full_matrices
         else
            full_storage = .true.
         endif

         ! Find determinant from LU decomposition

         ! Initialize a matrix temporary
         if (copy_a) then
            allocate(amat(m,n),source=a)
         else
            amat => a
         endif




          ! Successful query
          if (info==0) then





          endif


    dgesdd_("A", &m, &n, a, &lda, s, u, &m, vt, &n, work, &lwork, iwork, &info);
    if (info) // handle error conditions here





                select case (info)
                   case (0)
                       ! Success: compute determinant

                       ! Start with real 1.0
                       det = 1.0_${rk}$
                       perm = 0
                       do k=1,n
                          if (ipiv(k)/=k) perm = perm+1
                          det = det*amat(k,k)
                       end do
                       if (mod(perm,2)/=0) det = -det

                   case (:-1)
                       err0 = linalg_state(this,LINALG_ERROR,'invalid matrix size a=[',m,',',n,']')
                   case (1:)
                       err0 = linalg_state(this,LINALG_ERROR,'singular matrix')
                   case default
                       err0 = linalg_state(this,LINALG_INTERNAL_ERROR,'catastrophic error')
                end select

                if (.not.copy_a) deallocate(amat)

         end select

         ! Process output and return
         1 call linalg_error_handling(err0,err)

     end subroutine stdlib_linalg_svd_dp


!!!     #:endfor

end module stdlib_linalg_determinant
